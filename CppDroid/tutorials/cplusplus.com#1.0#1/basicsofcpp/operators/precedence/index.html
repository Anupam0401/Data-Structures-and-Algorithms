
<h3>Precedence of operators</h3>
A single expression may have multiple operators. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>x = 5 + 7 % 2;</code></pre></td></tr></table></div>
<br>
<br>
In C++, the above expression always assigns 6 to variable <code>x</code>, because the <code>%</code> operator has a higher precedence than the <code>+</code> operator, and is always evaluated before. Parts of the expressions can be enclosed in parenthesis to override this precedence order, or to make explicitly clear the intended effect. Notice the difference:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>x = 5 + (7 % 2);    <cite>// x = 6 (same as without parenthesis)</cite>
x = (5 + 7) % 2;    <cite>// x = 0 </cite></code></pre></td></tr></table></div>
<br>
<br>
From greatest to smallest priority, C++ operators are evaluated in the following order:<br>
<table class="boxed"><tr><th>Level</th><th>Precedence group</th><th>Operator</th><th>Description</th><th>Grouping</th></tr>
<tr><td>1</td><td>Scope</td><td><code>::</code></td><td>scope qualifier</td><td>Left-to-right</td></tr>
<tr><td rowspan="4">2</td><td rowspan="4">Postfix (unary)</td><td><code>++ --</code></td><td>postfix increment / decrement</td><td rowspan="4">Left-to-right</td></tr>
<tr><td><code>()</code></td><td>functional forms</td></tr>
<tr><td><code>[]</code></td><td>subscript</td></tr>
<tr><td><code>. -&gt;</code></td><td>member access</td></tr>
<tr><td rowspan="7">3</td><td rowspan="7">Prefix (unary)</td><td><code>++ --</code></td><td>prefix increment / decrement</td><td rowspan="7">Right-to-left</td></tr>
<tr><td><code>~ !</code></td><td>bitwise NOT / logical NOT</td></tr>
<tr><td><code>+ -</code></td><td>unary prefix</td></tr>
<tr><td><code>& *</code></td><td>reference / dereference</td></tr>
<tr><td><code>new delete</code></td><td>allocation / deallocation</td></tr>
<tr><td><code>sizeof</code></td><td>parameter pack</td></tr>
<tr><td><code>(<i>type</i>)</code></td><td>C-style type-casting</td></tr>
<tr><td>4</td><td>Pointer-to-member</td><td><code>.* -&gt;*</code></td><td>access pointer</td><td>Left-to-right</td></tr>
<tr><td>5</td><td>Arithmetic: scaling</td><td><code>* / %</code></td><td>multiply, divide, modulo</td><td>Left-to-right</td></tr>
<tr><td>6</td><td>Arithmetic: addition</td><td><code>+ -</code></td><td>addition, subtraction</td><td>Left-to-right</td></tr>
<tr><td>7</td><td>Bitwise shift</td><td><code>&lt;&lt; &gt;&gt;</code></td><td>shift left, shift right</td><td>Left-to-right</td></tr>
<tr><td>8</td><td>Relational</td><td><code>&lt; &gt; &lt;= &gt;=</code></td><td>comparison operators</td><td>Left-to-right</td></tr>
<tr><td>9</td><td>Equality</td><td><code>== !=</code></td><td>equality / inequality</td><td>Left-to-right</td></tr>
<tr><td>10</td><td>And</td><td><code>&</code></td><td>bitwise AND</td><td>Left-to-right</td></tr>
<tr><td>11</td><td>Exclusive or</td><td><code>^</code></td><td>bitwise XOR</td><td>Left-to-right</td></tr>
<tr><td>12</td><td>Inclusive or</td><td><code>|</code></td><td>bitwise OR</td><td>Left-to-right</td></tr>
<tr><td>13</td><td>Conjunction</td><td><code>&&</code></td><td>logical AND</td><td>Left-to-right</td></tr>
<tr><td>14</td><td>Disjunction</td><td><code>||</code></td><td>logical OR</td><td>Left-to-right</td></tr>
<tr><td rowspan="2">15</td><td rowspan="2">Assignment-level expressions</td><td><code>= *= /= %= += -=<br>
&gt;&gt;= &lt;&lt;= &= ^= |=</code></td><td>assignment / compound assignment</td><td rowspan="2">Right-to-left</td></tr>
<tr><td><code>?:</code></td><td>conditional operator</td></tr>
<tr><td>16</td><td>Sequencing</td><td><code>,</code></td><td>comma separator</td><td>Left-to-right</td></tr>
</table>
<br>
When an expression has two operators with the same precedence level, <i>grouping</i> determines which one is evaluated first: either left-to-right or right-to-left.<br>
<br>
Enclosing all sub-statements in parentheses (even those unnecessary because of their precedence) improves code readability.<br>
