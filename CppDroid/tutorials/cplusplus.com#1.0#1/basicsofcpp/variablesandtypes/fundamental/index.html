
<h3>Fundamental data types</h3>
The values of variables are stored somewhere in an unspecified location in the computer memory as zeros and ones. Our program does not need to know the exact location where a variable is stored; it can simply refer to it by its name. What the program needs to be aware of is the kind of data stored in the variable. It's not the same to store a simple integer as it is to store a letter or a large floating-point number; even though they are all represented using zeros and ones, they are not interpreted in the same way, and in many cases, they don't occupy the same amount of memory.<br>
<br>
Fundamental data types are basic types implemented directly by the language that represent the basic storage units supported natively by most systems. They can mainly be classified into:<br>
<ul>
<li><b>Character types:</b> They can represent a single character, such as <code>'A'</code> or <code>'$'</code>. The most basic type is <code>char</code>, which is a one-byte character. Other types are also provided for wider characters.</li>
<li><b>Numerical integer types:</b> They can store a whole number value, such as <code>7</code> or <code>1024</code>. They exist in a variety of sizes, and can either be <i>signed</i> or <i>unsigned</i>, depending on whether they support negative values or not.</li>
<li><b>Floating-point types:</b> They can represent real values, such as <code>3.14</code> or <code>0.01</code>, with different levels of precision, depending on which of the three floating-point types is used.</li>
<li><b>Boolean type:</b> The boolean type, known in C++ as <code>bool</code>, can only represent one of two states, <code>true</code> or <code>false</code>.</li>
</ul>
<br>
Here is the complete list of fundamental types in C++:<br>
<table class="boxed">
<tr><th>Group</th><th>Type names*</th><th>Notes on size / precision</th></tr>
<tr><td rowspan="4">Character types</td><td><code><b>char</b></code></td><td>Exactly one byte in size. At least 8 bits.</td></tr>
<tr><td><code><b>char16_t</b></code></td><td>Not smaller than <code>char</code>. At least 16 bits.</td></tr>
<tr><td><code><b>char32_t</b></code></td><td>Not smaller than <code>char16_t</code>. At least 32 bits.</td></tr>
<tr><td><code><b>wchar_t</b></code></td><td>Can represent the largest supported character set.</td></tr>
<tr><td rowspan="5">Integer types (signed)</td><td><code><b>signed char</b></code></td><td>Same size as <code>char</code>. At least 8 bits.</td></tr>
<tr><td><code><i>signed</i> <b>short</b> <i>int</i></code></td><td>Not smaller than <code>char</code>. At least 16 bits.</td></tr>
<tr><td><code><i>signed</i> <b>int</b></code></td><td>Not smaller than <code>short</code>. At least 16 bits.</td></tr>
<tr><td><code><i>signed</i> <b>long</b> <i>int</i></code></td><td>Not smaller than <code>int</code>. At least 32 bits.</td></tr>
<tr><td><code><i>signed</i> <b>long long</b> <i>int</i></code></td><td>Not smaller than <code>long</code>. At least 64 bits.</td></tr>
<tr><td rowspan="5">Integer types (unsigned)</td><td><code><b>unsigned char</b></code></td><td rowspan="5">(same size as their signed counterparts)</td></tr>
<tr><td><code><b>unsigned short</b> <i>int</i></code></td></tr>
<tr><td><code><b>unsigned</b> <i>int</i></code></td></tr>
<tr><td><code><b>unsigned long</b> <i>int</i></code></td></tr>
<tr><td><code><b>unsigned long long</b> <i>int</i></code></td></tr>
<tr><td rowspan="3">Floating-point types</td><td><code><b>float</b></code></td><td></td></tr>
<tr><td><code><b>double</b></code></td><td>Precision not less than <code>float</code></td></tr>
<tr><td><code><b>long double</b></code></td><td>Precision not less than <code>double</code></td></tr>
<tr><td>Boolean type</td><td><code><b>bool</b></code></td><td></td></tr>
<tr><td>Void type</td><td><code><b>void</b></code></td><td>no storage</td></tr>
<tr><td>Null pointer</td><td><code><b>decltype(nullptr)</b></code></td><td></td></tr>
</table>
<br>
* The names of certain integer types can be abbreviated without their <code>signed</code> and <code>int</code> components - only the part not in italics is required to identify the type, the part in italics is optional. I.e., <code><i>signed</i> short <i>int</i></code> can be abbreviated as <code>signed short</code>, <code>short int</code>, or simply <code>short</code>; they all identify the same fundamental type.<br>
<br>
Within each of the groups above, the difference between types is only their size (i.e., how much they occupy in memory): the first type in each group is the smallest, and the last is the largest, with each type being at least as large as the one preceding it in the same group. Other than that, the types in a group have the same properties.<br>
<br>
Note in the panel above that other than <code>char</code> (which has a size of exactly one byte), none of the fundamental types has a standard size specified (but a minimum size, at most). Therefore, the type is not required (and in many cases is not) exactly this minimum size. This does not mean that these types are of an undetermined size, but that there is no standard size across all compilers and machines; each compiler implementation may specify the sizes for these types that fit the best the architecture where the program is going to run. This rather generic size specification for types gives the C++ language a lot of flexibility to be adapted to work optimally in all kinds of platforms, both present and future. <br>
<br>
Type sizes above are expressed in bits; the more bits a type has, the more distinct values it can represent, but at the same time, also consumes more space in memory:<br>
<br>
<table class="boxed">
<tr><th>Size</th><th>Unique representable values</th><th>Notes</th></tr>
<tr><td>8-bit</td><td class="right"><code>256</code></td><td>= 2<sup>8</sup></td></tr>
<tr><td>16-bit</td><td class="right"><code>65 536</code></td><td>= 2<sup>16</sup></td></tr>
<tr><td>32-bit</td><td class="right"><code>4 292 967 296</code></td><td>= 2<sup>32</sup> (~4 billion)</td></tr>
<tr><td>64-bit</td><td class="right"><code>18 446 744 073 309 551 616</code></td><td>= 2<sup>64</sup> (~18 billion billion)</td></tr>
</table>
<br>
For integer types, having more representable values means that the range of values they can represent is greater; for example, a 16-bit unsigned integer would be able to represent 65536 distinct values in the range 0 to 65535, while its signed counterpart would be able to represent, on most cases, values between -32768 and 32767. Note that the range of positive values is approximately halved in signed types compared to unsigned types, due to the fact that one of the 16 bits is used for the sign; this is a relatively modest difference in range, and seldom justifies the use of unsigned types based purely on the range of positive values they can represent.<br>
<br>
For floating-point types, the size affects their precision, by having more or less bits for their significant and exponent.<br>
<br>
If the size or precision of the type is not a concern, then <code>char</code>, <code>int</code>, and <code>double</code> are typically selected to represent characters, integers, and floating-point values, respectively. The other types in their respective groups are only used in very particular cases.<br>
<br>
The properties of fundamental types in a particular system and compiler implementation can be obtained by using the <samp><a href="/numeric_limits">numeric_limits</a></samp> classes (see standard header <code><a href="/&lt;limits&gt;">&lt;limits&gt;</a></code>). If for some reason, types of specific sizes are needed, the library defines certain fixed-size type aliases in header <code><a href="/&lt;cstdint&gt;">&lt;cstdint&gt;</a></code>.<br>
<br>
The types described above (characters, integers, floating-point, and boolean) are collectively known as arithmetic types. But two additional fundamental types exist: <code>void</code>, which identifies the lack of type; and the type <code>nullptr</code>, which is a special type of pointer. Both types will be discussed further in a coming chapter about pointers.<br>
<br>
C++ supports a wide variety of types based on the fundamental types discussed above; these other types are known as <i>compound data types</i>, and are one of the main strengths of the C++ language. We will also see them in more detail in future chapters.<br>
