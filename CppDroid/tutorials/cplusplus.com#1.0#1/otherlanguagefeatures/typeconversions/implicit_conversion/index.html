
<h3>Implicit conversion</h3>
Implicit conversions are automatically performed when a value is copied to a compatible type. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>short</var> a=2000;
<var>int</var> b;
b=a;</code></pre></td></tr></table></div>
<br>
<br>
Here, the value of <code>a</code> is promoted from <code>short</code> to <code>int</code> without the need of any explicit operator. This is known as a <i>standard conversion</i>. Standard conversions affect fundamental data types, and allow the conversions between numerical types (<code>short</code> to <code>int</code>, <code>int</code> to <code>float</code>, <code>double</code> to <code>int</code>...), to or from <code>bool</code>, and some pointer conversions.<br>
<br>
Converting to <code>int</code> from some smaller integer type, or to <code>double</code> from <code>float</code> is known as <i>promotion</i>, and is guaranteed to produce the exact same value in the destination type. Other conversions between arithmetic types may not always be able to represent the same value exactly:<br>
<ul>
<li>If a negative integer value is converted to an unsigned type, the resulting value corresponds to its 2's complement bitwise representation (i.e., <code>-1</code> becomes the largest value representable by the type, <code>-2</code> the second largest, ...).</li>
<li>The conversions from/to <code>bool</code> consider <code>false</code> equivalent to <i>zero</i> (for numeric types) and to <i>null pointer</i> (for pointer types); <code>true</code> is equivalent to all other values and is converted to the equivalent of <code>1</code>.</li>
<li>If the conversion is from a floating-point type to an integer type, the value is truncated (the decimal part is removed). If the result lies outside the range of representable values by the type, the conversion causes <i>undefined behavior</i>.</li>
<li>Otherwise, if the conversion is between numeric types of the same kind (integer-to-integer or floating-to-floating), the conversion is valid, but the value is <i>implementation-specific</i> (and may not be portable).</li>
</ul>
<br>
Some of these conversions may imply a loss of precision, which the compiler can signal with a warning. This warning can be avoided with an explicit conversion.<br>
<br>
For non-fundamental types, arrays and functions implicitly convert to pointers, and pointers in general allow the following conversions:<br>
<ul>
<li><i>Null pointers</i> can be converted to pointers of any type</li>
<li>Pointers to any type can be converted to <code>void</code> pointers.</li>
<li>Pointer <i>upcast</i>: pointers to a derived class can be converted to a pointer of an <i>accessible</i> and <i>unambiguous</i> base class, without modifying its <code>const</code> or <code>volatile</code> qualification.<br>
</ul>
