<div style='float:left;padding:8px 8px 8px 0px;'>
</div><p>Now that you&#8217;ve learned some basics about programs, let&#8217;s look more closely at how to design a program.  When you sit down to write a program, generally you have some sort of problem that you&#8217;d like to solve, or situation that you&#8217;d like to simulate.  New programmers often have trouble figuring out how to convert that idea into actual code.  But it turns out, you have many of the problem solving skills you need already, acquired from every day life.</p>
<p>The most important thing to remember (and hardest thing to do) is to design your program <i>before you start coding</i>.  In many regards, programming is like architecture.  What would happen if you tried to build a house without following an architectural plan?  Odds are, unless you were very talented, you&#8217;d end up with a house that had a lot of problems: leaky roofs, walls that weren&#8217;t straight, etc&#8230;  Similarly, if you try to program before you have a good gameplan moving forward, you&#8217;ll likely find that your code has a lot of problems, and you&#8217;ll have to spend a lot of time fixing problems that could have been avoided altogether with a little design.</p>
<p>A little up-front planning will save you both time and frustration in the long run.</p>
<p><strong>Step 1: Define the problem</strong></p>
<p>The first thing you need to figure out is what problem your program is attempting to solve.  Ideally, you should be able to state this in a sentence or two.  For example:</p>
<ul>
<li>I want to write a phone book application to help me keep track of my friend&#8217;s phone numbers.
<li>I want to write a random dungeon generator that will produce interesting looking caverns.
<li>I want to write a program that will take information about stocks and attempt to predict which ones I should buy.
</ul>
<p>Although this step seems obvious, it&#8217;s also highly important.  The worst thing you can do is write a program that doesn&#8217;t actually do what you (or your boss) wanted!</p>
<p><strong>Step 2: Define your targets</strong></p>
<p>When you are an experienced programmer, there are many other steps that typically would take place at this point, including:</p>
<ul>
<li>Understanding who your target user is
<li>Defining what target architecture and/or OS your program will run on
<li>Determining what set of tools you will be using
<li>Determining whether you will write your program alone or as part of a team
<li>Collecting requirements (a documented list of what the program should do)
</ul>
<p>However, as a new programmer, the answers to these questions are typically simple: You are writing a program for your own use, alone, on your own system, using an IDE you purchased or downloaded.  This makes things easy, so we won&#8217;t spend any time on this step.</p>
<p><strong>Step 3: Make a heirarchy of tasks</strong></p>
<p>In real life, we often need to perform tasks that are very complex.  Trying to figure out how to do these tasks can be very challenging.  In such cases, we often make use of the <strong>top down</strong> method of problem solving.  That is, instead of solving a single complex task, we break that task into multiple subtasks, each of which is individually easier to solve.  If those subtasks are still too difficult to solve, they can be broken down further.  By continuously splitting complex tasks into simpler ones, you can eventually get to a point where each individual task is manageable, if not trivial.</p>
<p>Let&#8217;s take a look at an example of this.  Let&#8217;s say we want to write a report on carrots.  Our task hierarchy currently looks like this:</p>
<ul>
<li>Write report on carrots</li>
</ul>
<p>Writing a report on carrots is a pretty big task to do in one sitting, so let&#8217;s break it into subtasks:</p>
<ul>
<li>Write report on carrots</li>
<ul>
<li>Do research on carrots</li>
<li>Write outline</li>
<li>Fill in outline with details about carrots</li>
</ul>
</ul>
<p>That&#8217;s a more managable, as we now have three tasks that we can focus on individually.  However, in this case, &#8220;Do research on carrots is somewhat vague&#8221;, so we can break it down further:</p>
<ul>
<li>Write report on carrots</li>
<ul>
<li>Do research on carrots</li>
<ul>
<li>Go to library and get book on carrots</li>
<li>Look for information about carrots on internet</li>
</ul>
<li>Write outline</li>
<ul>
<li>Information about growing</li>
<li>Information about processing</li>
<li>Information about nutrition</li>
</ul>
<li>Fill in outline with details about carrots</li>
</ul>
</ul>
<p>Now we have a hierarchy of tasks, none of them particularly hard.  By completing each of these relatively manageable sub-items, we can complete the more difficult overall task of writing a report on carrots.</p>
<p>The other way to create a hierarchy of tasks is to do so from the <strong>bottom up</strong>.  In this method, we&#8217;ll start from a list of easy tasks, and construct the hierarchy by grouping them.</p>
<p>As an example, many people have to go to work or school on weekdays, so let&#8217;s say we want to solve the problem of &#8220;get from bed to work&#8221;.  If you were asked what tasks you did in the morning to get from bed to work, you might come up with the following list:</p>
<ul>
<li>Pick out clothes</li>
<li>Get dressed</li>
<li>Eat breakfast</li>
<li>Drive to work</li>
<li>Brush your teeth</li>
<li>Get out of bed</li>
<li>Prepare breakfast</li>
<li>Get in your car</li>
<li>Take a shower</li>
</ul>
<p>Using the bottom up method, we can organize these into a hierarchy of items by looking for ways to group items with similarities together:</p>
<ul>
<li>Get from bed to work</li>
<ul>
<li>Bedroom things</li>
<ul>
<li>Get out of bed</li>
<li>Pick out clothes</li>
</ul>
<li>Bathroom things</li>
<ul>
<li>Take a shower</li>
<li>Brush your teeth</li>
</ul>
<li>Breakfast things</li>
<ul>
<li>Prepare breakfast</li>
<li>Eat breakfast</li>
</ul>
<li>Transportation things</li>
<ul>
<li>Get in your car</li>
<li>Drive to work</li>
</ul>
</ul>
</ul>
<p>As it turns out, these task hierarchies are extremely useful in programming, because once you have a task hierarchy, you have essentially defined the structure of your overall program.  The top level task (in this case, &#8220;Write a report on carrots&#8221; or &#8220;Get from bed to work&#8221;) becomes main() (because it is the main item you are trying to solve).  The subitems become functions in the program.</p>
<p>If it turns out that one of the items (functions) is too difficult to implement, simply split that item into multiple subitems, and have that function call multiple subfunctions that implement those new tasks.  Eventually you should reach a point where each function in your program is trivial to implement.</p>
<p><strong>Step 4: Figure out the sequence of events</strong></p>
<p>Now that your program has a structure, it&#8217;s time to determine how to link all the tasks together.  The first step is to determine the sequence of events that will be performed.  For example, when you get up in the morning, what order do you do the above tasks?  It might look like this:</p>
<ul>
<li>Get out of bed</li>
<li>Pick out clothes</li>
<li>Take a shower</li>
<li>Get dressed</li>
<li>Prepare breakfast</li>
<li>Eat breakfast</li>
<li>Brush your teeth</li>
<li>Get in your car</li>
<li>Drive to work</li>
</ul>
<p>If we were writing a calculator, we might do things in this order:</p>
<ul>
<li>Get first number from user</li>
<li>Get mathematical operation from user</li>
<li>Get second number from user</li>
<li>Calculate result</li>
<li>Print result</li>
</ul>
<p>This list essentially defines what will go into your main() function:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
int main()
{
    GetOutOfBed();
    PickOutClothes();
    TakeAShower();
    GetDressed();
    PrepareBreakfast();
    EatBreakfast();
    BrushTeeth();
    GetInCar();
    DriveToWork();
}
</pre></td></tr></table>
<p>Or in the case of the calculator:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
int main()
{
    // Get first number from user
    GetUserInput();

    // Get mathematical operation from user
    GetMathematicalOperation();

    // Get second number from user
    GetUserInput();

    // Calculate result
    CalculateResult();

    // Print result
    PrintResult();
}
</pre></td></tr></table>
<p><strong>Step 5: Figure out the data inputs and outputs for each task</strong></p>
<p>Once you have a hierarchy and a sequence of events, the next thing to do is figure out what input data each task needs to operate, and what data it produces (if any).  If you already have the input data from a previous step, that input data will become a parameter.  If you are calculating output for use by some other function, that output will generally become a return value.</p>
<p>When we are done, we should have prototypes for each function.  In case you&#8217;ve forgotten, a <strong>function prototype</strong> is a declaration of a function that includes the function&#8217;s name, parameters, and return type, but does not implement the function.</p>
<p>Let&#8217;s do a couple examples.  GetUserInput() is pretty straightforward.  We&#8217;re going to get a number from the user and return it back to the caller.  Thus, the function prototype would look like this:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
int GetUserInput()
</pre></td></tr></table>
<p>In the calculator example, the CalculateResult() function will need to take 3 pieces of input: Two numbers and a mathematical operator.  We should already have all three of these by the time we get to the point where this function is called, so these three pieces of data will be function parameters.  The CalculateResult() function will calculate the result value, but it does not display the result itself.  Consequently, we need to return that result as a return value so that other functions can use it.</p>
<p>Given that, we could write the function prototype like this:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
int CalculateResult(int nInput1, char chOperator, int nInput2);
</pre></td></tr></table>
<p><strong>Step 6: Write the task details</strong></p>
<p>In this step, for each task, you will write it&#8217;s actual implementation.  If you have broken the tasks down into small enough pieces, each task should be fairly simple and straightforward.  If a given task still seems overly-complex, perhaps it needs to be broken down into subtasks that can be more easily implemented.</p>
<p>For example:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
char GetMathematicalOperation()
{
    cout &lt;&lt; &quot;Please enter an operator (+,-,*,or /): &quot;;

    char chOperation;
    cin &gt;&gt; chOperation;

    // What if the user enters an invalid character?
    // We'll ignore this possibility for now
    return chOperation;
}
</pre></td></tr></table>
<p><strong>Step 7: Connect the data inputs and outputs</strong></p>
<p>Finally, the last step is to connect up the inputs and outputs of each task in whatever way is appropriate.  For example, you might send the output of CalculateResult() into an input of PrintResult(), so it can print the calculated answer.  This will often involve the use of intermediary variables to temporary store the result so it can be passed between functions.  For example:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
// nResult is a temporary value used to transfer the output of CalculateResult()
// into an input of PrintResult()
int nResult = CalculateResult(nInput1, chOperator, nInput2);
PrintResult(nResult);
</pre></td></tr></table>
<p>This tends to be much more readable than the alternative condensed version that doesn&#8217;t use a temporary variable:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
PrintResult( CalculateResult(nInput1, chOperator, nInput2) );
</pre></td></tr></table>
<p>This is often the hardest step for new programmers to get the hang of.</p>
<p>Note: To fully complete this example, you&#8217;ll need to utilize <a href="http://www.learncpp.com/cpp-tutorial/52-if-statements/">if statements</a>, which we won&#8217;t cover for a while, but you&#8217;re welcome to take a sneak-peak at now.</p>
<p>A fully completed version of the above calculator sample follows (hidden in case you want to take a stab at it yourself first):</p>
<p><a class="solution_link_show" href="javascript:void(0)" onclick="wpSolutionToggle(document.getElementById('id2111230911'), this, 'Show Solution', 'Hide Solution')">Show Solution</a></p>
<div class="solution_div" id="id2111230911" style="display:none">
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
#include &quot;stdafx.h&quot;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int GetUserInput()
{
    cout &lt;&lt; &quot;Please enter an integer: &quot;;
    int nValue;
    cin &gt;&gt; nValue;
    return nValue;
}

char GetMathematicalOperation()
{
    cout &lt;&lt; &quot;Please enter an operator (+,-,*,or /): &quot;;

    char chOperation;
    cin &gt;&gt; chOperation;
    // What if the user enters an invalid character?
    // We'll ignore this possibility for now
    return chOperation;
}

int CalculateResult(int nX, char chOperation, int nY)
{
    if (chOperation=='+')
        return nX + nY;
    if (chOperation=='-')
        return nX - nY;
    if (chOperation=='*')
        return nX * nY;
    if (chOperation=='/')
        return nX / nY;

    return 0;
}

void PrintResult(int nResult)
{
    cout &lt;&lt; &quot;Your result is: &quot; &lt;&lt; nResult &lt;&lt; endl;
}

int main()
{
    // Get first number from user
    int nInput1 = GetUserInput();

    // Get mathematical operation from user
    char chOperator = GetMathematicalOperation();

    // Get second number from user
    int nInput2 = GetUserInput();

    // Calculate result
    int nResult = CalculateResult(nInput1, chOperator, nInput2);

    // Print result
    PrintResult(nResult);
}
</pre></td></tr></table>
</div>
<p><strong>Words of advice when writing programs</strong></p>
<p><strong>Keep your program simple to start</strong>.  Often new programmers have a grand vision for all the things they want their program to do.  &#8220;I want to write a role-playing game with graphics and sound and random monsters and dungeons, with a town you can visit to sell the items that you find in the dungeon&#8221;  If you try to write something too complex to start, you will become overwhelmed and discouraged at your lack of progress.   Instead, make your first goal as simple as possible, something that is definitely within your reach.  For example, &#8220;I want to be able to display a 2d representation of the world on the screen&#8221;.</p>
<p><strong>Add features over time</strong>.  Once you have your simple program working and working well, then you can add features to it.  For example, once you can display your 2d world, add a character who can walk around.  Once you can walk around, add walls that can impede your progress.  Once you have walls, build a simple town out of them.  Once you have a town, add merchants.  By adding each feature incrementally your program will get progressively more complex without overwhelming you in the process.</p>
<p><strong>Focus on one area at a time</strong>.  Don&#8217;t try to code everything at once, and don&#8217;t divide your attention across multiple tasks.  Focus on one task at a time, and see it through to completion as much as is possible.  It is much better to have one fully working task and five that haven&#8217;t been started yet than six partially-working tasks.  If you split your attention, you are more likely to make mistakes and forget important details.</p>
<p><strong>Test each piece of code as you go</strong>.  New programmers will often write the entire program in one pass.  Then when they compile it for the first time, the compiler reports hundreds of errors.  This can not only be intimidating, if your code doesn&#8217;t work, it may be hard to figure out why.  Instead, write a piece of code, and then compile and test it immediately.  If it doesn&#8217;t work, you&#8217;ll know exactly where the problem is, and it will be easy to fix.  Once you are sure that the code works, move to the next piece and repeat.  It may take longer to finish writing your code, but when you are done the whole thing should work, and you won&#8217;t have to spend twice as long trying to figure out why it doesn&#8217;t.</p>
<p>Most new programmers will shortcut many of these steps and suggestions (because it seems like a lot of work and/or it&#8217;s not as much fun as writing the code).  However, for any non-trivial project, following these steps will definitely save you a lot of time in the long run.  A little planning up front saves a lot of debugging at the end.</p>
<p>The good news is that once you become comfortable with all of these concepts, they will start coming naturally to you without even thinking about it.  Eventually you will get to the point where you can write entire functions without any pre-planning at all.</p>
