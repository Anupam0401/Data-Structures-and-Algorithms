<div style='float:left;padding:8px 8px 8px 0px;'>
</div><p>As you learned in the lesson on <a href="http://www.learncpp.com/?p=37">basic addressing</a>, memory on modern machines is typically organized into byte-sized pieces, with each piece having a unique address.  Up to this point, it has been useful to think of memory as a bunch of cubbyholes or mailboxes where we can put and retrieve information, and variables as names for accessing those cubbyholes or mailboxes.</p>
<p>However, this analogy is not quite correct in one regard &#8212; most variables actually take up more than 1 byte of memory.  Consequently, a single variable may use 2, 4, or even 8 consecutive memory addresses.  The amount of memory that a variable uses is based on it&#8217;s data type.  Fortunately, because we typically access memory through variable names and not memory addresses, the compiler is largely able to hide the details of working with different sized variables from us.</p>
<p>There are several reasons it is useful to know how much memory a variable takes up.</p>
<p>First, the more memory a variable takes up, the more information it can hold.  Because each bit can only hold a 0 or a 1, we say that bit can store 2 values.  2 bits can store 4 different values:</p>
<table border=1 cellspacing=0 cellpadding=3>
<tr>
<th>bit 0</th>
<th>bit 1</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>3 bits can store 8 values.  n bits can store 2^n values.  Because a byte is 8 bits, a byte can store 2^8 (256) values.</p>
<p>The size of the variable puts a limit on the amount of information it can store &#8212; variables that are bigger can hold larger numbers.  We will address this issue further when we get into the different types of variables.</p>
<p>Second, computers have a finite amount of free memory.  Every time we declare a variable, a small portion of that free memory is used as long as the variable is in existence.  Because modern computers have a lot of memory, this often isn&#8217;t a problem, especially if only declaring a few variables.  However, for programs that need a large amount of variables (eg. 100,000), the difference between using 1 byte and 8 byte variables can be significant.</p>
<p>The obvious next question is &#8220;how much memory do variables of different data types take?&#8221;.  The size of a given data type is dependent on the compiler and/or the computer architecture.  On most 32-bit machines (as of this writing), a char is 1 byte, a bool is 1 byte, a short is 2 bytes, an int is 4 bytes, a long is 4 bytes, a float is 4 bytes, and a double is 8 bytes.</p>
<p>In order to determine the size of data types on a particular machine, C++ provides an operator named sizeof.  The <strong>sizeof operator</strong> is a unary operator that takes either a type or a variable, and returns its size in bytes.  You can compile and run the following program to find out how large your data types are:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
#include &lt;iostream&gt;

int main()
{
    using namespace std;
    cout &lt;&lt; &quot;bool:\t\t&quot; &lt;&lt; sizeof(bool) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;char:\t\t&quot; &lt;&lt; sizeof(char) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;wchar_t:\t&quot; &lt;&lt; sizeof(wchar_t) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;short:\t\t&quot; &lt;&lt; sizeof(short) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;int:\t\t&quot; &lt;&lt; sizeof(int) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;long:\t\t&quot; &lt;&lt; sizeof(long) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;float:\t\t&quot; &lt;&lt; sizeof(float) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;double:\t\t&quot; &lt;&lt; sizeof(double) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;long double:\t&quot; &lt;&lt; sizeof(long double) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
    return 0;
}
</pre></td></tr></table>
<p>Here is the output from the author&#8217;s Pentium 4 machine, using Visual Studio 2005 Express:</p>
<pre>
bool:           1 bytes
char:           1 bytes
wchar_t:        2 bytes
short:          2 bytes
int:            4 bytes
long:           4 bytes
float:          4 bytes
double:         8 bytes
long double:    8 bytes
</pre>
<p>Your results may vary if you are using a different type of machine, or a different compiler.</p>
<p>If you&#8217;re wondering what \t is in the above program, it&#8217;s a special symbol that inserts a tab.  We will cover \t and other special symbols when we talk about the char data type.</p>
<p>Interestingly, the sizeof operator is one of only three operators in C++ that is a word instead of a symbol.  The other two are <em>new</em> and <em>delete</em>.</p>
<p>You can also use the sizeof operator on a variable name:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
    int x;
    cout &lt;&lt; &quot;x is &quot; &lt;&lt; sizeof(x) &lt;&lt; &quot; bytes&quot;&lt;&lt;endl;
</pre></td></tr></table>
<pre>
x is 4 bytes
</pre>
<p>Now you know enough about variables that we can start discussing the different data types!</p>
