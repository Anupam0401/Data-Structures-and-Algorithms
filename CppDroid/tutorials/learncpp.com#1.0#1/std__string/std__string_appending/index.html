<div style='float:left;padding:8px 8px 8px 0px;'>
</div><p><strong>Appending</strong></p>
<p>Appending strings to the end of an existing string is easy using either operator+=, append(), or push_back() function.</p>
<table border=1 cellspacing=0 cellpadding=3 width=100%>
<tr>
<td>
<b>string&#038; string::operator+= (const string&#038; str)</b><br />
<b>string&#038; string::append (const string&#038; str)</b><br />
</p>
<ul>
<li>Both functions append the characters of str to the string.
<li>Both function return *this so they can be &#8220;chained&#8221;.
<li>Both functions throw a length_error exception if the result exceeds the maximum number of characters.
</ul>
<p>Sample code:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
string sString(&quot;one&quot;);

sString += string(&quot; two&quot;);

string sThree(&quot; three&quot;);
sString.append(sThree);

cout &lt;&lt; sString &lt;&lt; endl;
</pre></td></tr></table>
<p>Output:</p>
<pre>
one two three
</pre>
</td>
</tr>
</table>
<p></p>
<p>There&#8217;s also a flavor of append() that can append a substring:</p>
<table border=1 cellspacing=0 cellpadding=3 width=100%>
<tr>
<td>
<b>string&#038; string::append (const string&#038; str, size_type index, size_type num)</b></p>
<ul>
<li>This function appends num characters from str, starting at index, to the string.
<li>Returns *this so it can be &#8220;chained&#8221;.
<li>Throws an out_of_range if index is out of bounds
<li>Throws a length_error exception if the result exceeds the maximum number of characters.
</ul>
<p>Sample code:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
string sString(&quot;one &quot;);

const string sTemp(&quot;twothreefour&quot;);
sString.append(sTemp, 3, 5); // append substring of sTemp starting at index 3 of length 5
cout &lt;&lt; sString &lt;&lt; endl;
</pre></td></tr></table>
<p>Output:</p>
<pre>
one three
</pre>
</td>
</tr>
</table>
<p></p>
<p>Operator+= and append() also have versions that work on C-style strings:</p>
<table border=1 cellspacing=0 cellpadding=3 width=100%>
<tr>
<td>
<b>string&#038; string::operator+= (const char* str)</b><br />
<b>string&#038; string::append (const char* str)</b><br />
</p>
<ul>
<li>Both functions append the characters of str to the string.
<li>Both function return *this so they can be &#8220;chained&#8221;.
<li>Both functions throw a length_error exception if the result exceeds the maximum number of characters.
<li>str should not be NULL.
</ul>
<p>Sample code:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
string sString(&quot;one&quot;);

sString += &quot; two&quot;;
sString.append(&quot; three&quot;);
cout &lt;&lt; sString &lt;&lt; endl;
</pre></td></tr></table>
<p>Output:</p>
<pre>
one two three
</pre>
</td>
</tr>
</table>
<p></p>
<p>There is an additional flavor of append() that works on C-style strings:</p>
<table border=1 cellspacing=0 cellpadding=3 width=100%>
<tr>
<td>
<b>string&#038; string::append (const char* str, size_type len)</b><br />
</p>
<ul>
<li>Appends the first len characters of str to the string.
<li>Returns *this so they can be &#8220;chained&#8221;.
<li>Throw a length_error exception if the result exceeds the maximum number of characters.
<li>Ignores special characters (including &#8216;\0&#8242;)
</ul>
<p>Sample code:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
string sString(&quot;one&quot;);

sString.append(&quot;threefour&quot;, 5);
cout &lt;&lt; sString &lt;&lt; endl;
</pre></td></tr></table>
<p>Output:</p>
<pre>
one three
</pre>
<p>This function is dangerous and its use is not recommended.</p>
</td>
</tr>
</table>
<p></p>
<p>There is also a set of functions that append characters.  Note that the name of the non-operator function to append a character is push_back(), not append()!</p>
<table border=1 cellspacing=0 cellpadding=3 width=100%>
<tr>
<td>
<b>string&#038; string::operator+= (char c)</b><br />
<b>void string::push_back (char c)</b><br />
</p>
<ul>
<li>Both functions append the the character c to the string.
<li>Operator += returns *this so it can be &#8220;chained&#8221;.
<li>Both functions throw a length_error exception if the result exceeds the maximum number of characters.
</ul>
<p>Sample code:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
string sString(&quot;one&quot;);

sString += ' ';
sString.append('2');
cout &lt;&lt; sString &lt;&lt; endl;
</pre></td></tr></table>
<p>Output:</p>
<pre>
one 2
</pre>
<p>Now you might be wondering why the name of the function is push_back() and not append().  This follows a naming convention used for stacks, where push_back() is the function that adds a single item to the end of the stack.  If you envision a string as a stack of characters, using push_back() to add a single character to the end makes sense.  However, the lack of an append() function is inconsistent in my view!</p>
</td>
</tr>
</table>
<p></p>
<p>It turns out there is an append() function for characters, that looks like this:</p>
<table border=1 cellspacing=0 cellpadding=3 width=100%>
<tr>
<td>
<b>string&#038; string::append (size_type num, char c)</b><br />
</p>
<ul>
<li>Adds num occurrences of the character c to the string
<li>Returns *this so it can be &#8220;chained&#8221;.
<li>Throws a length_error exception if the result exceeds the maximum number of characters.
</ul>
<p>Sample code:</p>
<table><tr><td class="source"><pre class="brush: cpp; title: ; notranslate" title="">
string sString(&quot;aaa&quot;);

sString.append(4, 'b');
cout &lt;&lt; sString &lt;&lt; endl;
</pre></td></tr></table>
<p>Output:</p>
<pre>
aaabbbb
</pre>
</td>
</tr>
</table>
<p></p>
<p>There&#8217;s one final flavor of append() that you won&#8217;t understand unless you know what iterators are.  If you&#8217;re not familiar with iterators, you can ignore this function.</p>
<table border=1 cellspacing=0 cellpadding=3 width=100%>
<tr>
<td>
<b>string&#038; string::append (InputIterator start, InputIterator end)</b><br />
</p>
<ul>
<li>Appends all characters from the range [start, end) (including start up to but not including end)
<li>Returns *this so it can be &#8220;chained&#8221;.
<li>Throws a length_error exception if the result exceeds the maximum number of characters.
</ul>
</td>
</tr>
</table>
<p></p>
